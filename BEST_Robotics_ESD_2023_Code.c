#pragma config(UART_Usage, UART1, uartUserControl, baudRate1200, IOPins, None, None)
#pragma config(Sensor, port1,  liftSensorR,    sensorVexIQ_Touch)
#pragma config(Sensor, port3,  liftSensorL,    sensorVexIQ_Touch)
#pragma config(Sensor, port5,  armSensorR,    sensorVexIQ_Touch)
#pragma config(Sensor, port7,  armSensorL,    sensorVexIQ_Touch)
#pragma config(Motor,  motor2,          motorR,        tmotorNone, openLoop, driveRight)
#pragma config(Motor,  motor5,          motorLift,     tmotorVexIQ, openLoop)
#pragma config(Motor,  motor6,          motorArm,      tmotorVexIQ, openLoop)
#pragma config(Motor,  motor9,          motorL,        tmotorVexIQ, openLoop, driveLeft)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// custom baud rate set code
typedef unsigned long uint32_t;
typedef unsigned short uint16_t;
typedef struct {
	uint16_t SR;
	uint16_t RESERVED0;
	uint16_t DR;
	uint16_t RESERVED1;
	uint16_t BRR;
	uint16_t RESERVED2;
	uint16_t CR1;
	uint16_t RESERVED3;
	uint16_t CR2;
	uint16_t RESERVED4;
	uint16_t CR3;
	uint16_t RESERVED5;
	uint16_t GTPR;
	uint16_t RESERVED6;
} USART_TypeDef;

/* Peripheral memory map */
#define PERIPH_BASE ((unsigned long)0x40000000)
#define APB1PERIPH_BASE PERIPH_BASE
#define USART2_BASE (APB1PERIPH_BASE + 0x4400)
#define USART3_BASE (APB1PERIPH_BASE + 0x4800)
#define USART2 ((USART_TypeDef *) USART2_BASE)
#define USART3 ((USART_TypeDef *) USART3_BASE)



void setBaud( const TUARTs nPort, int baudRate ) {
	uint32_t tmpreg = 0x00, apbclock = 0x00;
	uint32_t integerdivider = 0x00;
	uint32_t fractionaldivider = 0x00;

	/* pclk1 - 36MHz */
	apbclock = 36000000;

	/* Determine the integer part */
	integerdivider = ((0x19 * apbclock) / (0x04 * (baudRate)));
	tmpreg = (integerdivider / 0x64) << 0x04;

	/* Determine the fractional part */
	fractionaldivider = integerdivider - (0x64 * (tmpreg >> 0x04));
	tmpreg |= ((((fractionaldivider * 0x10) + 0x32) / 0x64)) & 0x0F;

	/* Write to USART BRR */
	USART_TypeDef *uart = USART2;
	if( nPort == UART2 ) {
		uart = USART3;
	}
	uart->BRR = (uint16_t)tmpreg;
}

float moveMult = 1; // Movement speed multiplier.
int moveLowerBound = 20; // Movement sensitivity.
int armLowerBound = 40; // Arm sensitivity.
int moveMode = 1; // Movement setting; tank movement is 1, arcade movement is 2.
int armState = 2; // Field robot center lever states for IR; 1 is rotate, 2 is drive, 3 is lift.
int mode = 1; // Normal mode is 1, sensitive mode is 2.
short ch = 0xAA; // IR character storage.

task sensitivity_mode { // Toggle sensitivity mode.
	if(vexRT[Btn5D]) {
		if (mode == 1) {
			mode = 2;
			moveMult = 0.5;
			} else if (mode == 2) {
			mode = 1;
			moveMult = 1;
		}
	}
	wait1Msec(500);
}

task move_mode {
	if(vexRT[Btn7D]) { // toggle between arcade and tank controls
		if(moveMode == 1) {
			moveMode = 2;
			} else {
			moveMode = 1;
		}
		wait1Msec(500);
	}
}

task move { // Movement of the robot itself.
	if(moveMode == 1) { // tank controls
		if(abs(vexRT[Ch3]) > moveLowerBound) {
			motor[motorL] = vexRT[Ch3]*moveMult;
			} else {
			motor[motorL] = 0;
		}
		if(abs(vexRT[Ch2]) > moveLowerBound) {
			motor[motorR] = vexRT[Ch2]*moveMult;
			} else {
			motor[motorR] = 0;
		}
		} else { // arcade controls
		if(abs(vexRT[Ch2]-vexRT[Ch1]) > moveLowerBound) {
			motor[motorR] = (vexRT[Ch2]-vexRT[Ch1])*moveMult;
			} else {
			motor[motorR] = 0;
		}
		if(abs(vexRT[Ch2]+vexRT[Ch1]) > moveLowerBound) {
			motor[motorL] = (vexRT[Ch2]+vexRT[Ch1])*moveMult;
			} else {
			motor[motorL] = 0;
		}
	} // end if
} // end task

task arm { // Arm movement.

	if(vexRT[Btn8D] && SensorValue[liftSensorR] != 0){ // button pressed and snap action switch is off
		motor[motorLift] = 127;
		} else if (vexRT[Btn8U] && SensorValue[liftSensorL] != 0) { // and snap action switch is off
		motor[motorLift] = -127;
		} else {
		motor[motorLift] = 0;
	}
	if(vexRT[Btn7D] && SensorValue[armSensorR] != 0) { // and snap action switch is off
		motor[motorArm] = 127;
		} else if (vexRT[Btn7U] && SensorValue[armSensorL] != 0) { // and snap action switch is off
		motor[motorArm] = -127;
		} else {
		motor[motorArm] = 0;
	}
} // end task

task autonomous {
	if (vexRT[Btn7L] && vexRT[Btn7R]) {
		while(true) {
			if (vexRT[Btn8L] && vexRT[Btn8R]) {
				break;
			}
			// follow the track with IR, make way down to brain itself
			// lift arm up to highest position and insert
			// how the hell do we do this
		}
	}
}


	task main { // Runs all the tasks above.
		setBaud(UART1, 600); // Sets the infared rate of the IR transmitter.
		while (true) {
			startTask(move_mode);
			startTask(sensitivity_mode);
			startTask(move);
			startTask(arm);
		}
	} // end main
