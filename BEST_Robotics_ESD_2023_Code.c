#pragma config(UART_Usage, UART1, uartUserControl, baudRate1200, IOPins, None, None)
#pragma config(Sensor, in1,    liftSensorR,    sensorVexIQ_Touch)
#pragma config(Sensor, in3,    liftSensorL,    sensorVexIQ_Touch)
#pragma config(Sensor, in5,    armSensorR,     sensorVexIQ_Touch)
#pragma config(Sensor, in6,    irSensorR,      sensorAnalog)
#pragma config(Sensor, in7,    armSensorL,     sensorVexIQ_Touch)
#pragma config(Sensor, in8,    irSensorL,      sensorAnalog)
#pragma config(Sensor, in4,    tipOfRobotSensor, sensorVexIQ_Touch)
#pragma config(Motor,  port2,           motorR,        tmotorNone, openLoop)
#pragma config(Motor,  port5,           motorLift,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           motorArm,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           motorL,        tmotorVex393_MC29, openLoop, driveLeft)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// custom baud rate set code


typedef unsigned long uint32_t;
typedef unsigned short uint16_t;
typedef struct {
	uint16_t SR;
	uint16_t RESERVED0;
	uint16_t DR;
	uint16_t RESERVED1;
	uint16_t BRR;
	uint16_t RESERVED2;
	uint16_t CR1;
	uint16_t RESERVED3;
	uint16_t CR2;
	uint16_t RESERVED4;
	uint16_t CR3;
	uint16_t RESERVED5;
	uint16_t GTPR;
	uint16_t RESERVED6;
} USART_TypeDef;

/* Peripheral memory map */
#define PERIPH_BASE ((unsigned long)0x40000000)
#define APB1PERIPH_BASE PERIPH_BASE
#define USART2_BASE (APB1PERIPH_BASE + 0x4400)
#define USART3_BASE (APB1PERIPH_BASE + 0x4800)
#define USART2 ((USART_TypeDef *) USART2_BASE)
#define USART3 ((USART_TypeDef *) USART3_BASE)



void setBaud( const TUARTs nPort, int baudRate ) {
	uint32_t tmpreg = 0x00, apbclock = 0x00;
	uint32_t integerdivider = 0x00;
	uint32_t fractionaldivider = 0x00;

	/* pclk1 - 36MHz */
	apbclock = 36000000;

	/* Determine the integer part */
	integerdivider = ((0x19 * apbclock) / (0x04 * (baudRate)));
	tmpreg = (integerdivider / 0x64) << 0x04;

	/* Determine the fractional part */
	fractionaldivider = integerdivider - (0x64 * (tmpreg >> 0x04));
	tmpreg |= ((((fractionaldivider * 0x10) + 0x32) / 0x64)) & 0x0F;

	/* Write to USART BRR */
	USART_TypeDef *uart = USART2;
	if( nPort == UART2 ) {
		uart = USART3;
	}
	uart->BRR = (uint16_t)tmpreg;
}

float moveMult = 1; // Movement speed multiplier.
float autonomousMoveMult = 0.1; // Movement speed multiplier for autonomous mode
float baseAutonomousMoveMult = 0.1; // Base movement speed multiplier for autonomous mode
bool deadReckoningDone = false; // Stop condition for an autonomous loop
int moveLowerBound = 20; // Movement sensitivity.
int armLowerBound = 40; // Arm sensitivity.
int currentPositionInTermsOfA = 0; // reference autonomous subfunctions to see what A is
int moveMode = 1; // Movement setting; tank movement is 1, arcade movement is 2, autonomous mode is 3.
int mode = 1; // Normal mode is 1, sensitive mode is 2.
int target1 = 0; // Targeted brain
int target2 = 0; // Targeted brain

task sensitivity_mode { // Toggle sensitivity mode.
	if(vexRT[Btn5D]) {
		if (mode == 1) {
			mode = 2;
			moveMult = 0.5;
			} else if (mode == 2) {
			mode = 1;
			moveMult = 1;
		}
	}
	wait1Msec(500);
}

task move_mode {
	if(vexRT[Btn7D]) { // toggle between arcade and tank controls
		if(moveMode == 1) {
			moveMode = 2;
			} else {
			moveMode = 1;
		}
		wait1Msec(500);
	}
}

task move { // Movement of the robot itself.
	if(moveMode == 1) { // tank controls
		if(abs(vexRT[Ch3]) > moveLowerBound) {
			motor[motorL] = vexRT[Ch3]*moveMult;
			} else {
			motor[motorL] = 0;
		}
		if(abs(vexRT[Ch2]) > moveLowerBound) {
			motor[motorR] = vexRT[Ch2]*moveMult;
			} else {
			motor[motorR] = 0;
		}
		} else { // arcade controls
		if(abs(vexRT[Ch2]-vexRT[Ch1]) > moveLowerBound) {
			motor[motorR] = (vexRT[Ch2]-vexRT[Ch1])*moveMult;
			} else {
			motor[motorR] = 0;
		}
		if(abs(vexRT[Ch2]+vexRT[Ch1]) > moveLowerBound) {
			motor[motorL] = (vexRT[Ch2]+vexRT[Ch1])*moveMult;
			} else {
			motor[motorL] = 0;
		}
	} // end if
} // end task

task arm { // Arm movement.

	if(vexRT[Btn8D] && SensorValue[liftSensorR] != 0){ // button pressed and snap action switch is off
		motor[motorLift] = 127;
		} else if (vexRT[Btn8U] && SensorValue[liftSensorL] != 0) { // and snap action switch is off
		motor[motorLift] = -127;
		} else {
		motor[motorLift] = 0;
	}
	if(vexRT[Btn7D] && SensorValue[armSensorR] != 0) { // and snap action switch is off
		motor[motorArm] = 127;
		} else if (vexRT[Btn7U] && SensorValue[armSensorL] != 0) { // and snap action switch is off
		motor[motorArm] = -127;
		} else {
		motor[motorArm] = 0;
	}
} // end task

void backA() // A is the distance between the center of one pipe to the center of another one.
{
	motor[motorR] = -127;
	motor[motorL] = -127;
	wait1Msec(500); // some constant that needs to be determined
	motor[motorR] = 0;
	motor[motorL] = 0;
}
void forwardA()
{
	motor[motorR] = 127;
	motor[motorL] = 127;
	wait1Msec(500); // some constant that needs to be determined
	motor[motorR] = 0;
	motor[motorL] = 0;
}
void backB() // B is a set distance that the robot backs up do, doesn't really matter.
{
	motor[motorR] = -127;
	motor[motorL] = -127;
	wait1Msec(500); // some constant that needs to be determined
	motor[motorR] = 0;
	motor[motorL] = 0;
}
void forwardB()
{
	motor[motorR] = 127;
	motor[motorL] = 127;
	wait1Msec(500); // some constant that needs to be determined
	motor[motorR] = 0;
	motor[motorL] = 0;
}
void right90Degrees()
{
	motor[motorR] = -127;
	motor[motorL] = 127;
	wait1Msec(500); // some constant that needs to be determined
	motor[motorR] = 0;
	motor[motorL] = 0;
}
void left90Degrees()
{
	motor[motorR] = 127;
	motor[motorL] = -127;
	wait1Msec(500); // some constant that needs to be determined
	motor[motorR] = 0;
	motor[motorL] = 0;
}
void extendArm()
{
	// no clue what the motors for this are, let alone the numbers
}
task autonomous {
	if (vexRT[Btn7L] && vexRT[Btn7R]) {
		deadReckoningDone = false;
		target1 = 0;
		target2 = 0;
		moveMode = 3;
		while(true) {
			if (vexRT[Btn5U] && vexRT[Btn6U]) { // Cancels autonomous mode
				moveMode = 1;
				break;
			}
			if (vexRT[Btn7L]){ // This determines what brains are taken
				if(target1 == 0){target1 = 1;}
				else{target2 = 1;} // Target leftmost brain
			}
			if (vexRT[Btn7R]){
				if(target1 == 0){target1 = 2;}
				else{target2 = 2;} // Target midleft brain
			}
			if (vexRT[Btn8L]){
				if(target1 == 0){target1 = 3;}
				else{target2 = 3;} // Target midright brain
			}
			if (vexRT[Btn8R]){
				if(target1 == 0){target1 = 4;}
				else{target2 = 4;} // Target rightmost brain
			}
			if (target1 != 0 && target2 != 0){
				while(true){ // This doesn't need a case for both, because at that point it would be off of the track.
					if (vexRT[Btn5U] && vexRT[Btn6U]) { // Cancels autonomous mode
						moveMode = 1;
						break;
					}
					if (SensorValue[irSensorR] > 100){ // If the sensor sees the white
						motor[motorR] = 127*autonomousMoveMult; // Turn the robot so it is realligned
						motor[motorL] = 127*baseAutonomousMoveMult;
						autonomousMoveMult += 0.0001; // Every time it iterates add a multiplier to movement speed

					}
					else if (SensorValue[irSensorL] > 100){ // If the sensor sees the white
						motor[motorR] = 127*baseAutonomousMoveMult; // Turn the robot so it is realligned
						motor[motorL] = 127*autonomousMoveMult;
						autonomousMoveMult += 0.0001; // Every time it iterates add a multiplier

					}
					else {
						autonomousMoveMult = 0.1; // Base multiplier, changing this changes the speed of autonomous mode. a
						motor[motorR] = 127*baseAutonomousMoveMult; // Go forward!
						motor[motorL] = 127*baseAutonomousMoveMult;
					}
					if (autonomousMoveMult > 1) {autonomousMoveMult = 1;} // Guard against move mult going past range of the motor
					if (SensorValue[tipOfRobotSensor] == 0){
						currentPositionInTermsOfA = 2;
						while(deadReckoningDone != true){ // Use dead reckoning for the brains, no other way to do this.
							// so essentially there are two variables here, A and B. A is the distance between the center of a target
							// and the space between two targets. B is a set distance to back up to. So, back up, turn, go A until
							// robot's position is equal to the position of the target (in A), grab brain, do again for the second target,
							// then break loop
							if (vexRT[Btn5U] && vexRT[Btn6U]) { // Cancels autonomous mode
								moveMode = 1;
								break;
							}
							backB(); // go back to a position away from the brain
							if(target1 <= 2){ // need to go left
								left90Degrees();
								while(currentPositionInTermsOfA > target1*2)
								{
									if (vexRT[Btn5U] && vexRT[Btn6U]) { // Cancels autonomous mode
										moveMode = 1;
										break;
									}
									forwardA();
									currentPositionInTermsOfA--;
								}
								right90Degrees();
								forwardB();
								extendArm();
							}
							else{ // need to go right
								right90Degrees();
								while(currentPositionInTermsOfA < target1*2)
								{
									if (vexRT[Btn5U] && vexRT[Btn6U]) { // Cancels autonomous mode
										moveMode = 1;
										break;
									}
									forwardA();
									currentPositionInTermsOfA++;
								}
								left90Degrees();
								forwardB();
								extendArm();
							}
							backB();
							if(target2*2 <= currentPositionInTermsOfA){
								left90Degrees();
								while(currentPositionInTermsOfA > target2*2)
								{
									if (vexRT[Btn5U] && vexRT[Btn6U]) { // Cancels autonomous mode
										moveMode = 1;
										break;
									}
									forwardA();
									currentPositionInTermsOfA--;
								}
								right90Degrees();
								forwardB();
								extendArm();


							}
							else{
								right90Degrees();
								while(currentPositionInTermsOfA < target2*2)
								{
									if (vexRT[Btn5U] && vexRT[Btn6U]) { // Cancels autonomous mode
										moveMode = 1;
										break;
									}
									forwardA();
									currentPositionInTermsOfA++;
								}
								left90Degrees();
								forwardB();
								extendArm();


							}
							backB();
							deadReckoningDone = true;
						}

					}
				}
			}
		}
		moveMode = 1;
	}
}


task main { // Runs all the tasks above.
	setBaud(UART1, 600); // Sets the infared rate of the IR transmitter.
	while (true) {
		startTask(move_mode);
		startTask(sensitivity_mode);
		startTask(move);
		startTask(arm);
		startTask(autonomous);
	}
} // end main
